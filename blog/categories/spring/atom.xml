<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Spring | 范琪的个人博客]]></title>
  <link href="http://www.fanqi.xyz/blog/categories/spring/atom.xml" rel="self"/>
  <link href="http://www.fanqi.xyz/"/>
  <updated>2016-05-27T12:32:01+08:00</updated>
  <id>http://www.fanqi.xyz/</id>
  <author>
    <name><![CDATA[范琪]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spring中的Propagation属性配置]]></title>
    <link href="http://www.fanqi.xyz/blog/2016/05/18/the-propagation-properties-in-the-spring/"/>
    <updated>2016-05-18T11:25:34+08:00</updated>
    <id>http://www.fanqi.xyz/blog/2016/05/18/the-propagation-properties-in-the-spring</id>
    <content type="html"><![CDATA[<h2>应用场景</h2>

<pre><code>&lt;tx:advice id="txadvice" transaction-manager="transactionManager"&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name="*" propagation="REQUIRED"/&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre>

<p>其中，<code>propagation</code>的属性值有<code>REQUIRED</code>、<code>SUPPORTS</code>、<code>MANDATORY</code>、<code>REQUIRES_NEW</code>、<code>NOT_SUPPORTED</code>、<code>NEVER</code>、<code>NESTED</code>等7种，默认是<code>REQUIRED</code>。<br/>
1. <code>REQUIRED</code>:如果存在一个事务，则支持当前事务;如果没有事务则开启。<br/>
2. <code>SUPPORTS</code>:如果存在一个事务，支持当前事务;如果没有事务，则非事务的执行。<br/>
3. <code>MANDATORY</code>:如果已经存在一个事务，支持当前事务;如果没有一个活动的事务，则抛出异常。<br/>
4. <code>REQUIRES_NEW</code>:总是开启一个新的事务;如果一个事务存在，则将这个存在的事务挂起。<br/>
5. <code>NOT_SUPPORTED</code>:总是非事务地执行;并挂起任何存在的事务。<br/>
6. <code>NEVER</code>:总是非事务地执行，如果存在一个活动事务，则抛出异常。<br/>
7. <code>NESTED</code>:如果一个活动的事务存在，则运行在一个嵌套的事务中，如果没有活动事务，则按<code>REQUIRED</code>属性执行。</p>

<h2>解决嵌套事务异常的问题</h2>

<h3>源代码</h3>

<p>DataSyncManager.java<br/>
``` java
public class DataSyncManager {</p>

<p>public void syncData() {
    syncData(null);
}
public void syncData(String code) {
    //递归同步
    //syncData(code)
}
<code>
applicationContext.xml:  
</code> xml
&lt;tx:advice id=&ldquo;txadvice&rdquo; transaction-manager=&ldquo;transactionManager&rdquo;>
    &lt;tx:attributes>
        &lt;tx:method name=&ldquo;<em>&rdquo; propagation=&ldquo;REQUIRED&rdquo;/>
        &lt;tx:method name=&ldquo;sync</em>&rdquo; propagation=&ldquo;REQUIRED&rdquo;/>
    &lt;/tx:attributes>
&lt;/tx:advice>
```</p>

<h3>异常信息</h3>

<p>每次数据同步完成之后就会爆出错误，然后事务回滚，同步失败。
```
ERROR [org.quarz.core.ErrorLogger 2185] - <Job <DEFAULT.syncDataListenerJobThrew an exception.>
org.springframework.scheduling.quartz.JobMethodInvocationFailedException: Invocation of method &lsquo;syncData&rsquo; on target class [class com.text.db.manager.DataSyncManager$$EnhancerByCGLIB$$b012b05e] failed; nested exception is org.springframework.transaction.UnexceptedRollbackException: Transaction rolled back because it has been marked as rollback-only
&hellip;</p>

<blockquote><p>```</p></blockquote>

<h3>问题分析</h3>

<p>根据原有配置，执行syncData()方法会创建事务，随后执行syncData(code)方法，以及递归方法都会支持当前事务，从而形成一个庞大的事务，在同步多天历史数据的情况下，很不可取，一旦出了问题，所有数据都会回滚。</p>

<h3>解决办法</h3>

<p>将事务进行拆分，一旦某阶段的数据同步成功，就提交事务，下一阶段的数据同步重新创建事务。<br/>
DataSyncManager.java<br/>
``` java
public class DataSyncManager {</p>

<p>public void initSyncData() {
    syncData(null);
}
public void syncData(String code) {
    //递归同步
    //syncData(code)
}
<code>
applicationContext.xml:  
</code> xml
&lt;tx:advice id=&ldquo;txadvice&rdquo; transaction-manager=&ldquo;transactionManager&rdquo;>
    &lt;tx:attributes>
        &lt;tx:method name=&ldquo;syncData&rdquo; propagation=&ldquo;REQUIRES_NEW&rdquo;/>
        &lt;tx:method name=&ldquo;*&rdquo; propagation=&ldquo;SUPPORTS&rdquo;/>
    &lt;/tx:attributes>
&lt;/tx:advice>
```</p>
]]></content>
  </entry>
  
</feed>
